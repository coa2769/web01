<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <script src="js/three.js"></script>
    <script src="js/OrbitControls.js"></script>
    <script>
        let patText;
        let patArr;

        //shader data
        let lineVertShader = `
  attribute float lineDistance;
  varying float vLineDistance;
  
  void main() {
    vLineDistance = lineDistance;
    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
    gl_Position = projectionMatrix * mvPosition;
  }
  `;

        let lineFragShader = `
  uniform vec3 diffuse;
  uniform float opacity;

  uniform float dashSize;
  uniform float gapSize;
  uniform float dotSize;
  varying float vLineDistance;
  
  void main() {
		float totalSize = dashSize + gapSize;
		float modulo = mod( vLineDistance, totalSize );
    float dotDistance = dashSize + (gapSize * .5) - (dotSize * .5);
    
    if ( modulo > dashSize && mod(modulo, dotDistance) > dotSize ) {
      discard;
    }

    gl_FragColor = vec4( diffuse, opacity );
  }
  `;

        function readTextFile(file) {
            let rawFile = new XMLHttpRequest();
            rawFile.open('GET', file, false);
            rawFile.onreadystatechange = function() {
                if (rawFile.readyState === 4) {
                    if (rawFile.status === 200 || rawFile.status == 0) {
                        patText = rawFile.responseText;
                        console.log(rawFile.responseText);

                        //파싱
                        patArr = parsingPatFile(patText);
                        //랜더링
                        render();
                    }
                }
            };

            rawFile.send(null);
        }

        readTextFile('./info/CIRCLE32.PAT');
        // readTextFile('./info/dwgviewriso.pat');
        // readTextFile('./info/HPWAV4E0.pat');

        function parsingPatFile(text) {
            let arr = patText.split('\n');
            // console.log(arr);

            let patData = [];
            let pat = {
                name: '',
                data: []
            };

            let i;
            for (i = 0; i < arr.length; i++) {
                let word1 = '*';
                let word2 = ';;';

                //;;는 주석
                if (arr[i].includes(word2) == false) {
                    //*는 이 패턴의 이름과 내용. 다음 *게 나올 때까지 숫자 데이터
                    // console.log(arr[i][0]);
                    if (arr[i][0] == '*') {

                        if (pat.name != '') {
                            patData.push(pat);
                            pat = {
                                name: '',
                                data: []
                            };
                        }

                        let name = arr[i].split(',');
                        pat.name = name[0].slice(1, name[0].length);

                    }
                    //나머지는 숫자 데이터(.이나 숫자이면)
                    else if ((arr[i][0] !== undefined) && (arr[i][0] == '.' || arr[i][0].match(/[0-9]/g) != null)) {
                        //.으로 시작하는 숫자 데이터는 소숫점 (문자 => 숫자로 변환하는 함수 찾기)
                        let data = arr[i].split(',');
                        // console.log(data);

                        let line = {
                            angle: 0, //단위 : 각도법
                            oriX: 0, //선의 시작
                            oriY: 0, //선의 시작
                            deltaX: 0, //다음 줄의 선 이동
                            daltaY: 0, // 다음 줄의 선 이동
                            dash: [] //5개 이후의 값들은 dash
                        };

                        line.angle = Number(data[0]) * (Math.PI / 180);
                        // line.angle = Number(data[0]);
                        line.orix = Number(data[1]);
                        line.oriY = Number(data[2]);
                        line.deltaX = Number(data[3]);
                        line.deltaY = Number(data[4]);

                        let j;
                        for (j = 5; j < data.length; j++) {
                            line.dash.push(Number(data[j]));
                        }

                        pat.data.push(line);
                    }
                }
            }

            //마지막에 파싱한 pat도 추가
            patData.push(pat);
            console.log(patData);

            return patData;

        }

        //각도에 따라 선분 그리는 함수
        function clacPointOfLine(disX, disY, len, angle) {
            let pos = [];

            if (angle < 0) {
                angle = Math.PI * 2 + angle;
            }

            while (angle >= Math.PI) {
                angle -= Math.PI;
            }

            let angle2 = angle + Math.PI;


            //angle > 90 (x가 증가하면 y는 감소)
            if (angle > (Math.PI * 0.5) && angle < Math.PI) {
                pos.push({
                    x: len * 0.5 * Math.cos(angle) + disX,
                    y: len * 0.5 * Math.sin(angle) + disY
                });
                pos.push({
                    x: len * 0.5 * Math.cos(angle2) + disX,
                    y: len * 0.5 * Math.sin(angle2) + disY
                });
            }
            //angle == 90 (x만 증가)
            else if (angle == (Math.PI * 0.5)) {
                pos.push({
                    x: len * 0.5 * Math.cos(angle) + disX,
                    y: len * 0.5 * Math.sin(angle)
                });
                pos.push({
                    x: len * 0.5 * Math.cos(angle2) + disX,
                    y: len * 0.5 * Math.sin(angle2)
                });
            }
            //angle == 0 (y만 증가)
            else if (angle == 0) {
                pos.push({
                    x: len * 0.5 * Math.cos(angle),
                    y: len * 0.5 * Math.sin(angle) + disY
                });
                pos.push({
                    x: len * 0.5 * Math.cos(angle2),
                    y: len * 0.5 * Math.sin(angle2) + disY
                });
            }
            //angle < 90  (x가 증가하면 y는 증가)
            else if (angle < (Math.PI * 0.5)) {
                pos.push({
                    x: len * 0.5 * Math.cos(angle) + disX,
                    y: len * 0.5 * Math.sin(angle) - disY
                });
                pos.push({
                    x: len * 0.5 * Math.cos(angle2) + disX,
                    y: len * 0.5 * Math.sin(angle2) - disY
                });
            }

            return pos;

        }



        function render() {
            //1.
            let renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            let scene = new THREE.Scene();
            let camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
            camera.position.set(0, 0, 50);
            camera.lookAt(0, 0, 0);

            // let control = new THREE.OrbitControls(camera, document.body);
            // control.target.x = camera.position.x;
            // control.target.y = camera.position.y;
            // control.target.z = 0;
            // control.zoomSpeed = 3;

            // control.addEventListener('change', function() {
            //     renderer.render(scene, camera);
            // });

            let len = 50;

            //========================

            // let geometry = new THREE.BufferGeometry();
            // let vertices = new Float32Array(6);

            // vertices[0] = 50;
            // vertices[1] = 50;
            // vertices[2] = 0;

            // vertices[3] = -50;
            // vertices[4] = -50;
            // vertices[5] = 0;

            // geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));

            // let material = new THREE.LineDashedMaterial({
            //     color: 0xffff00,
            //     dashSize: 1,
            //     gapSize: 10
            // });

            // let line = new THREE.Line(geometry, material);
            // line.computeLineDistances();
            // scene.add(line);
            //=================================

            //circle32
            let obj = new THREE.Object3D();
            obj.position.x = 0;
            obj.position.y = 0;
            obj.position.z = 0;

            let count = 17;

            let i, j;
            for (i = 0; i < patArr[0].data.length; i++) {
                let pat = patArr[0].data[i];

                for (j = 0; j < count; j++) {
                    //나중에는 distance도 추가하여 그리기
                    let pos = clacPointOfLine(0, 0, len, pat.angle);
                    let geometry = new THREE.BufferGeometry();
                    let vertices = new Float32Array(6);

                    vertices[0] = pos[0].x;
                    vertices[1] = pos[0].y;
                    vertices[2] = 0;

                    vertices[3] = pos[1].x;
                    vertices[4] = pos[1].y;
                    vertices[5] = 0;

                    geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
                    // geometry.addAttribute('lineDistance', new THREE.BufferAttribute(new Float32Array([len]), 1));

                    let dashSize = 0;
                    let gapSize = 0;
                    let dotSize = 0;

                    if (pat.dash.length == 0) {
                        dashSize = 1;
                    }

                    let e;
                    for (e = 0; e < pat.dash.length; e++) {
                        if (pat.dash[e] == 0 || pat.dash[e] == 20) {
                            dotSize = 0.1;
                        }
                        //
                        else if (pat.dash[e] < 0) {
                            gapSize = Math.abs(pat.dash[e]);
                        }
                        //
                        else if (pat.dash[e] > 0) {
                            dashSize = pat.dash[e];
                        }
                    }

                    let material = new THREE.LineDashedMaterial({
                        color: 0xffff00,
                        dashSize: dashSize,
                        gapSize: gapSize
                    });

                    // let material = new THREE.LineBasicMaterial({
                    //     color: 0xffff00
                    // });

                    let line = new THREE.Line(geometry, material);
                    line.computeLineDistances();

                    obj.add(line);
                }

            }
            scene.add(obj);
            renderer.render(scene, camera);
        }

        // let pos = function(x, y) {
        //     this.x = x;
        //     this.y = y;
        // };

        // let arrLine = [];

        // //기울기 계산 : (pos2.y - pos1.y) / (pos2.x - pos1.x);

        // //왼쪽 아래 => 오른쪽 위 ( + )
        // arrLine.push(new pos(20, 60));
        // arrLine.push(new pos(30, 70));

        // //왼쪽 아래 => 오른쪽 위 ( + )
        // arrLine.push(new pos(40, 60));
        // arrLine.push(new pos(20, -70));

        // //왼쪽 아래 => 오른쪽 위 ( + )
        // arrLine.push(new pos(40, -10));
        // arrLine.push(new pos(20, -70));


        // //오른쪽 아래 => 왼쪽 위 ( - )
        // arrLine.push(new pos(20, 60));
        // arrLine.push(new pos(30, -70));


        // //선의 기울기
        // function slopeOfLine(pos1, pos2) {
        //     let disX = pos2.x - pos1.x;
        //     let disY = pos2.y - pos1.y;

        //     return (pos2.y - pos1.y) / (pos2.x - pos1.x);
        // }

        // //선 방정식의 상수
        // function constantOfLine(pos, slope) {
        //     //상수를 구하려면 기울기를 알아낸 선 방정식에 x,y값을 대입하여 계산
        //     return pos.y - (slope * pos.x);
        // }

        // let arrRect = [];
        // //1
        // arrRect.push(new pos(0, 50));
        // arrRect.push(new pos(50, 50));
        // //2
        // arrRect.push(new pos(50, 50));
        // arrRect.push(new pos(50, 0));
        // //3
        // arrRect.push(new pos(50, 0));
        // arrRect.push(new pos(0, 0));
        // //4
        // arrRect.push(new pos(0, 0));
        // arrRect.push(new pos(0, 50));

        // //교차점
        // let crossPos = [];

        // function clipping() {
        //     //x = mX + b (m : 기울기 = y증가량 / x증가량, b : 상수)
        //     //두 직선의 교차점은 두 직선의 방정식을 연립시켜서 구하게 됩니다.

        //     //직선A : Y = maX + ba (ma : 직선A 기울기, ba : 직선A 상수)
        //     //직선B : Y = mbX + bb (mb : 직선B 기울기, bb : 직선B 상수)

        //     //maX + ba = mbX + bb
        //     //maX + ba - (mbX + bb) = 0
        //     //(ma - mb)X (ba - bb) = 0

        //     //X = -(ba -bb)/(ma - mb)
        //     //Y = ma * (-(ba -bb)/(ma - mb)) + ba

        //     let i, j;
        //     for (j = 0; j < arrLine.length; j += 2) {
        //         console.log(`${j /2} 번째`);

        //         let ma = slopeOfLine(arrLine[j], arrLine[j + 1]);
        //         let ba = constantOfLine(arrLine[j], ma);
        //         console.log(' ma : ' + ma + ' ba : ' + ba);
        //         console.log('#####################################');

        //         for (i = 0; i < arrRect.length; i += 2) {

        //             //다각형의 선 방정식
        //             let mb = slopeOfLine(arrRect[i], arrRect[i + 1]);
        //             let bb = constantOfLine(arrRect[i], mb);

        //             console.log(' mb : ' + mb + ' bb : ' + bb);
        //             let x, y;

        //             //기울기 y증가량/x증가량 에서 x증가량이 0 이므로
        //             if (Math.abs(ma) !== Infinity && Math.abs(mb) !== Infinity) {
        //                 x = -(ba - bb) / (ma - mb);
        //                 y = ma * x + ba;
        //             } else {
        //                 if (Math.abs(ma) == Math.abs(mb)) {
        //                     x = NaN;
        //                     y = NaN;
        //                 } else if (Math.abs(ma) === Infinity) {
        //                     x = arrLine[j].x;
        //                     y = mb * x + bb;
        //                 } else if (Math.abs(mb) === Infinity) {
        //                     x = arrRect[i].y;
        //                     y = ma * x + ba;
        //                 }
        //             }

        //             // console.log(' ## x : ' + x + ' y : ' + y);
        //             console.log('====================================');

        //             if (!isNaN(x) && !isNaN(y)) {
        //                 let max = {
        //                     x: arrRect[i].x > arrRect[i + 1].x ? arrRect[i].x : arrRect[i + 1].x,
        //                     y: arrRect[i].y > arrRect[i + 1].y ? arrRect[i].y : arrRect[i + 1].y
        //                 };
        //                 let min = {
        //                     x: arrRect[i].x < arrRect[i + 1].x ? arrRect[i].x : arrRect[i + 1].x,
        //                     y: arrRect[i].y < arrRect[i + 1].y ? arrRect[i].y : arrRect[i + 1].y
        //                 };

        //                 // let max = {
        //                 //     x: arrLine[0].x > arrLine[1].x ? arrLine[0].x : arrLine[1].x,
        //                 //     y: arrLine[0].y > arrLine[1].y ? arrLine[0].y : arrLine[1].y
        //                 // }

        //                 // let min = {
        //                 //     x: arrLine[0].x < arrLine[1].x ? arrLine[0].x : arrLine[1].x,
        //                 //     y: arrLine[0].y < arrLine[1].y ? arrLine[0].y : arrLine[1].y
        //                 // }

        //                 if (x <= max.x && x >= min.x && y <= max.y && y >= min.y) {
        //                     crossPos.push(new pos(x, y));

        //                     // console.log(i + ' => ' + 'x : ' + x + '  y : ' + y);
        //                 }
        //             }
        //             // if (!isNaN(x) && !isNaN(y)) {
        //             //     crossPos.push(new pos(x, y));
        //             // }
        //         }
        //     }

        // }

        // let renderer = new THREE.WebGLRenderer();
        // renderer.setSize(window.innerWidth, window.innerHeight);
        // document.body.appendChild(renderer.domElement);

        // let scene = new THREE.Scene();
        // let camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
        // camera.position.set(0, 0, 200);
        // camera.lookAt(0, 0, 0);

        // let shape, geometry, material, mesh;

        // shape = new THREE.Shape();
        // shape.moveTo(arrRect[0].x, arrRect[0].y);
        // shape.lineTo(arrRect[1].x, arrRect[1].y);
        // shape.lineTo(arrRect[3].x, arrRect[3].y);
        // shape.lineTo(arrRect[5].x, arrRect[5].y);
        // shape.lineTo(arrRect[7].x, arrRect[7].y);

        // geometry = new THREE.ShapeBufferGeometry(shape);
        // material = new THREE.MeshBasicMaterial({
        //     color: 0xffff00
        // });
        // mesh = new THREE.Line(geometry, material);
        // scene.add(mesh);

        // clipping();

        // let max = {
        //     x: 50,
        //     y: 50
        // };
        // let min = {
        //     x: 0,
        //     y: 0
        // };
        // let size = 50;

        // //left : minX, top : maxY
        // //right : maxX, bottom : minY


        // let i;
        // for (i = 0; i < crossPos.length; i += 2) {

        //     geometry = new THREE.BufferGeometry();
        //     // let vertices = new Float32Array([
        //     //     arrLine[0].x, arrLine[0].y, 0,
        //     //     arrLine[1].x, arrLine[1].y, 0
        //     // ]);
        //     // let vertices = new Float32Array([
        //     //     crossPos[0].x, crossPos[0].y, 0,
        //     //     crossPos[1].x, crossPos[1].y, 0
        //     // ]);

        //     let vertices = new Float32Array(6);
        //     console.log(vertices);

        //     vertices[0] = crossPos[i].x;
        //     vertices[1] = crossPos[i].y;
        //     vertices[2] = 0;

        //     vertices[3] = crossPos[i + 1].x;
        //     vertices[4] = crossPos[i + 1].y;
        //     vertices[5] = 0;

        //     geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
        //     material = new THREE.MeshBasicMaterial({
        //         color: 0xffff00
        //     });
        //     mesh = new THREE.Line(geometry, material);
        //     scene.add(mesh);

        // }

        // //패턴이 있는 선분


        // renderer.render(scene, camera);
    </script>
</body>

</html>