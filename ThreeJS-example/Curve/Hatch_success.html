<!DOCTYPE html>
<html lang="en">

<head>
    <title>Example geometries-plane</title>
    <meta charset="UTF-8">
    <script src="../js/three.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <canvas id='canvas'></canvas>
    <div id="WebGL-output">

    </div>
    <script>
        let WIDTH = 400;
        let HEIGHT = 400;

        //로딩이 끝나면 Three.js를 숭행한다.
        function init() {
            //여기에 Three.js코드를 추가한다.
            let scene = new THREE.Scene();
            let camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
            camera.position.set(0, 0, 500);
            let renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            //html 추가
            document.body.appendChild(renderer.domElement);

            //Geometries
            //let geometry = THREE.PlaneGeometry(width, height, widthSegments, heightSegments);
            //widthSegments : 너비가 분할되어야 할 세그먼트의 수.
            //heightSegments : 높이가 분할되어야 할 세그먼트 수.
            //let geometry = new THREE.PlaneGeometry(WIDTH, HEIGHT, 20, 32);
            //let geometry = new THREE.CircleGeometry(20, 32);
            var heartShape = new THREE.Shape();

            heartShape.moveTo(0, 0);
            heartShape.lineTo(100, 0);
            heartShape.lineTo(100, 100);
            heartShape.lineTo(0, 100);
            heartShape.lineTo(-100, 50);

            //bezierCurveTo()함수는 path에 선언되어 있다.
            // heartShape.moveTo(25, 25);
            // heartShape.bezierCurveTo(25, 25, 20, 0, 0, 0);
            // heartShape.bezierCurveTo(30, 0, 30, 35, 30, 35);
            // heartShape.bezierCurveTo(30, 55, 10, 77, 25, 95);
            // heartShape.bezierCurveTo(60, 77, 80, 55, 80, 35);
            // heartShape.bezierCurveTo(80, 35, 80, 0, 50, 0);
            // heartShape.bezierCurveTo(35, 0, 25, 25, 25, 25);

            var geometry = new THREE.ShapeGeometry(heartShape);

            //canvas
            //let bitmap = document.createElement('canvas');
            let bitmap = document.querySelector('canvas');

            let ctx = bitmap.getContext('2d');
            bitmap.width = WIDTH;
            bitmap.height = HEIGHT;

            // ctx.fillStyle = 'red';
            // ctx.fillRect(0, 0, bitmap.width, bitmap.height);
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, bitmap.width, bitmap.height);

            //1. canvas는 직사각형외의 다른 도형을 그리기 위해서는 
            //하나 이상의 path와 여러점으로 이어진 선을 만들어야한다.
            ctx.beginPath();
            // ctx.strokeStyle = '#000000'; 선 색깔 변경

            //2. path 메소드 : 물체를 구설할 때 필요한 경로 설정
            //※ 중심점을 이동 시킨다.
            ctx.translate(bitmap.width / 2, bitmap.height / 2);
            //210 ,330
            ctx.rotate(90 * Math.PI / 180);

            ctx.lineWidth = 2;
            let x = -WIDTH;
            let y = -HEIGHT;
            ctx.scale(0.5, 0.5);

            for (i = 0; i < 200; i++) {
                ctx.strokeStyle = '#ff0000';
                ctx.moveTo(x, y + i * 30 + 1);
                ctx.lineTo(x + WIDTH * 2, y + i * 30 + 1);

                ctx.stroke(); //이걸로 선을 끊는다.
            }
            //3. 현재 하위 경로의 시작 부분과 연결된 직선을 추가
            //ctx.closePath();

            //다시 중심점을 원점으로
            ctx.translate(-(bitmap.width / 2), -(bitmap.height / 2));


            //texture
            let texture = new THREE.Texture(bitmap);
            texture.needsUpdate = true;
            texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(0.01, 0.01);

            //material
            let material = new THREE.MeshBasicMaterial({
                map: texture
            });

            // geometry.faceVertexUvs[0].push([
            //     new THREE.UV(0, 0),
            //     new THREE.UV(0, 1),
            //     new THREE.UV(1, 1),
            //     new THREE.UV(1, 0)
            // ]);

            // geometry.computeFaceNormals();
            // geometry.computeCentroids();
            // geometry.computeVertexNormals();

            // let material = new THREE.MeshBasicMaterial({
            //     color: 0xffff00
            //         // side: THREE.DoubleSide
            // });

            //mesh
            let plane = new THREE.Mesh(geometry, material);
            scene.add(plane);

            renderer.render(scene, camera);
            // let meshMaterial = new THREE.MeshNormalMaterial();
            // meshMaterial = THRE.DoubleSide;
            // var wireFrameMateri

        };

        window.onload = init;





        // /*
        //  *   x1  패턴이 적용될 위치 X(left)
        //  *   y1  패턴이 적용될 위치 Y(top)
        //  *   dx  패턴의 넓이
        //  *   dy  패턴의 높이
        //  *   delta 간격
        //  *   color 선 색상
        //  */
        // var hatchRect = function(x1, y1, dx, dy, delta, color) {
        //     ctx.rect(x1, y1, dx, dy);
        //     ctx.save();
        //     ctx.clip();
        //     //입력 받은 배열중 최대 값 반환.
        //     var majorAxe = _.max([dx, dy]);
        //     ctx.strokeStyle = color;
        //     //each : 요소 list에 callback함수를 반복 호출한다. (callback의 n : 값, i :index)
        //     //range : 각 및 지도 루프에 사용할 수 있는 유연하게 숫자화된 정수 목록을 만드는 기능.
        //     _.each(_.range(-1 * (majorAxe), majorAxe, delta), function(n, i) {
        //         ctx.beginPath();
        //         //왼쪽 선
        //         ctx.moveTo(n + x1, y1);
        //         //오른쪽 선
        //         ctx.lineTo(dy + n + x1, y1 + dy);
        //         ctx.stroke();
        //     })
        //     ctx.restore();
        // }
    </script>
</body>

</html>