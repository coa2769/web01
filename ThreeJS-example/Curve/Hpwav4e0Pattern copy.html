<!DOCTYPE html>
<html lang="en">

<head>
    <title>Example HPWAV4E0 Pattern</title>
    <meta charset="UTF-8">
    <script src="../js/three.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <div id="WebGL-output">

    </div>
    <script>
        /**
         * Returns the angle in radians of the vector (p1,p2). In other words, imagine
         * putting the base of the vector at coordinates (0,0) and finding the angle
         * from vector (1,0) to (p1,p2).
         * @param  {Object} p1 start point of the vector
         * @param  {Object} p2 end point of the vector
         * @return {Number} the angle
         */
        THREE.Math.angle2 = function(p1, p2) {
            var v1 = new THREE.Vector2(p1.x, p1.y);
            var v2 = new THREE.Vector2(p2.x, p2.y);
            v2.sub(v1); // sets v2 to be our chord
            v2.normalize();
            if (v2.y < 0) return -Math.acos(v2.x);
            return Math.acos(v2.x);
        };

        THREE.Math.polar = function(point, distance, angle) {
            var result = {};
            result.x = point.x + distance * Math.cos(angle);
            result.y = point.y + distance * Math.sin(angle);
            return result;
        };
        /**
         * Calculates points for a curve between two points
         * @param startPoint - the starting point of the curve
         * @param endPoint - the ending point of the curve
         * @param bulge - a value indicating how much to curve
         * @param segments - number of segments between the two given points
         * 키워드 : line bulge calculator 
         */
        THREE.BulgeGeometry = function(startPoint, endPoint, bulge, segments) {

            var vertex, i,
                center, p0, p1, angle,
                radius, startAngle,
                thetaAngle;

            THREE.Geometry.call(this);

            this.startPoint = p0 = startPoint ? new THREE.Vector2(startPoint.x, startPoint.y) : new THREE.Vector2(0, 0);
            this.endPoint = p1 = endPoint ? new THREE.Vector2(endPoint.x, endPoint.y) : new THREE.Vector2(1, 0);
            this.bulge = bulge = bulge || 1;

            //- PI/2 and PI/2 사이의 값이 반환된다. bulge로 
            angle = 4 * Math.atan(bulge);
            //v1.distanceTo(v2) : v1에서 v2까지의 거리 계산 
            radius = p0.distanceTo(p1) / 2 / Math.sin(angle / 2);
            //
            center = THREE.Math.polar(startPoint, radius, THREE.Math.angle2(p0, p1) + (Math.PI / 2 - angle / 2));

            this.segments = segments = segments || Math.max(Math.abs(Math.ceil(angle / (Math.PI / 18))), 6); // By default want a segment roughly every 10 degrees
            startAngle = THREE.Math.angle2(center, p0);
            thetaAngle = angle / segments;


            this.vertices.push(new THREE.Vector3(p0.x, p0.y, 0));

            for (i = 1; i <= segments - 1; i++) {

                vertex = THREE.Math.polar(center, Math.abs(radius), startAngle + thetaAngle * i);

                this.vertices.push(new THREE.Vector3(vertex.x, vertex.y, 0));
            }

        };

        THREE.BulgeGeometry.prototype = Object.create(THREE.Geometry.prototype);

        //=============================

        //지금 point에서 angle 방향으로 distance만큼 떨어져 있는 point 반환
        THREE.Math.clacPointOfLine = function(disX, disY, len, angle) {
            let pos = [];

            //angle을 360도 내의 각도
            while (angle > (Math.PI * 2) || (angle < 0)) {

                if (angle < 0) {
                    angle = angle + (Math.PI * 2);
                } else if (angle > (Math.PI * 2)) {
                    angle = angle - (Math.PI * 2);
                }
            }

            let angle1, angle2;
            //pos[0] ==> 왼쪽
            //pos[1] ==> 오른쪽

            //angle ==> 왼쪽
            if (angle >= Math.PI * 0.5 && angle < (Math.PI * 0.5 * 3)) {
                angle1 = angle;
                //왼쪽 위
                if (angle1 <= Math.PI) {
                    angle2 = angle1 + Math.PI;
                }
                //왼쪽 아래
                else {
                    angle2 = angle1 - Math.PI;
                }
            }
            //angle ==> 오른쪽
            else {
                angle2 = angle;
                //오른쪽 위
                if (angle2 >= 0 && angle2 < ) {
                    angle1 = angle + Math.PI;
                }
                //오른쪽 아래
                else {
                    angle2 = angle + Math.PI;
                }
            }



            let angle2 = angle + Math.PI;


            //angle > 90    ex) 180 / 4 * 3 = 135 (x가 증가하면 y는 감소)
            if (angle > (Math.PI * 0.5) && angle < Math.PI) {
                pos.push({
                    x: -len * 0.5 * Math.cos(angle) + disX,
                    y: len * 0.5 * Math.sin(angle) + disY
                });
                pos.push({
                    x: -len * 0.5 * Math.cos(angle2) + disX,
                    y: len * 0.5 * Math.sin(angle2) + disY
                });
            }
            //angle == 90 (x만 증가)
            else if (angle == (Math.PI * 0.5)) {
                pos.push({
                    x: -len * 0.5 * Math.cos(angle) + disX,
                    y: len * 0.5 * Math.sin(angle)
                });
                pos.push({
                    x: -len * 0.5 * Math.cos(angle2) + disX,
                    y: len * 0.5 * Math.sin(angle2)
                });
            }
            //angle == 0 (y만 증가)
            else if (angle == 0) {
                pos.push({
                    x: -len * 0.5 * Math.cos(angle),
                    y: len * 0.5 * Math.sin(angle) + disY
                });
                pos.push({
                    x: -len * 0.5 * Math.cos(angle2),
                    y: len * 0.5 * Math.sin(angle2) + disY
                });
            }
            //angle < 90    ex) 180 / 5 = 36 (x가 증가하면 y는 증가)
            else if (angle < (Math.PI * 0.5)) {
                pos.push({
                    x: -len * 0.5 * Math.cos(angle) + disX,
                    y: len * 0.5 * Math.sin(angle) - disY
                });
                pos.push({
                    x: -len * 0.5 * Math.cos(angle2) + disX,
                    y: len * 0.5 * Math.sin(angle2) - disY
                });
            }

            return pos;
        };

        //로딩이 끝나면 Three.js를 숭행한다.
        function init() {
            //여기에 Three.js코드를 추가한다.
            let scene = new THREE.Scene();
            let camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
            camera.position.set(0, 0, 500);
            let renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            //html 추가
            document.body.appendChild(renderer.domElement);

            //원래 0각도에서의 각 시작 점들
            //0, 30
            //25, 38
            //110, 30

            let scale = 1;

            //<spline에 대한>
            //spline선의 각 고지점의 간격
            let hDistance = 8 * scale;
            let wDistance = 25 * scale; //일정하게 하기 위해 25로 
            //다음 선의 간격
            let distance = 60 * scale;
            //시작 점
            let x = 0 * scale;
            let y = 30 * scale;

            //<pattern에 대한>
            let maxLen = 300;
            let rowCount = maxLen / distance;
            let colCount = maxLen / (wDistance * 2) + 1;

            let parent = new THREE.Object3D();
            let material = new THREE.LineBasicMaterial({
                color: 0xffff00
            });

            //===========================================================================
            let i, j, e;
            let upAngle = Math.atan(hDistance / wDistance);
            let downAngle = Math.atan(-hDistance / wDistance);
            let len = Math.sqrt(Math.pow(wDistance, 2) + Math.pow(hDistance, 2));
            let angle = Math.PI / 7;

            // THREE.Math.polar = function(point, distance, angle);

            //행
            for (i = 0; i < rowCount; i++) {

                let pos = THREE.Math.clacPointOfLine((distance * i), (distance * i), maxLen, angle);
                //중심이 되는 선을 간격 만큼 나눈다.
                // let oriLine = new THREE.LineCurve(new THREE.Vector2(pos[0].x, pos[0].y), new THREE.Vector2(pos[1].x, pos[1].y));
                // let points = oriLine.getPoints(colCount);

                let curve = new THREE.SplineCurve([new THREE.Vector2(pos[1].x, pos[1].y)]);
                //
                let downPos = new THREE.Vector2(pos[1].x, pos[1].y);
                let upPos;
                for (j = 0; j < colCount; j++) {
                    upPos = THREE.Math.polar(downPos, len, upAngle + angle);
                    downPos = THREE.Math.polar(upPos, len, downAngle + angle);

                    curve.points.push(new THREE.Vector2(upPos.x, upPos.y));
                    curve.points.push(new THREE.Vector2(downPos.x, downPos.y));
                }

                let curvePos = curve.getPoints(50);
                let geometry = new THREE.BufferGeometry().setFromPoints(curvePos);
                let spline = new THREE.Line(geometry, material);
                parent.add(spline);

            }

            scene.add(parent);

            let geometry = new THREE.Geometry();
            geometry.vertices.push(
                new THREE.Vector3((-maxLen * 0.5), (-maxLen * 0.5), 0),
                new THREE.Vector3((maxLen * 0.5), (-maxLen * 0.5), 0),
                new THREE.Vector3((maxLen * 0.5), (maxLen * 0.5), 0),
                new THREE.Vector3((-maxLen * 0.5), (maxLen * 0.5), 0),
                new THREE.Vector3((-maxLen * 0.5), (-maxLen * 0.5), 0)
            );

            let line = new THREE.Line(geometry, material);
            scene.add(line);

            // //행
            // for (i = 0; i < rowCount; i++) {

            //     let pos = THREE.Math.clacPointOfLine((-maxLen * 0.5) + (distance * i), maxLen, Math.PI * 0.5);
            //     //중심이 되는 선을 간격 만큼 나눈다.
            //     let oriLine = new THREE.LineCurve(new THREE.Vector2(pos[0].x, pos[0].y), new THREE.Vector2(pos[1].x, pos[1].y));
            //     let points = oriLine.getPoints(colCount * 2);

            //     let curve = new THREE.SplineCurve([new THREE.Vector2(points[0].x, points[0].y)]);

            //     for (j = 1; j < points.length; j += 2) {

            //         curve.points.push(new THREE.Vector2(points[j].x, points[j].y + hDistance));
            //         curve.points.push(new THREE.Vector2(points[j + 1].x, points[j + 1].y));
            //     }

            //     let curvePos = curve.getPoints(50);
            //     let geometry = new THREE.BufferGeometry().setFromPoints(curvePos);
            //     let spline = new THREE.Line(geometry, material);
            //     parent.add(spline);

            // }

            // scene.add(parent);

            // let geometry = new THREE.Geometry();
            // geometry.vertices.push(
            //     new THREE.Vector3((-maxLen * 0.5), (-maxLen * 0.5), 0),
            //     new THREE.Vector3((maxLen * 0.5), (-maxLen * 0.5), 0),
            //     new THREE.Vector3((maxLen * 0.5), (maxLen * 0.5), 0),
            //     new THREE.Vector3((-maxLen * 0.5), (maxLen * 0.5), 0),
            //     new THREE.Vector3((-maxLen * 0.5), (-maxLen * 0.5), 0)
            // );

            // let line = new THREE.Line(geometry, material);
            // scene.add(line);
            //===========================================================================


            renderer.render(scene, camera);
        };

        init();
    </script>
</body>

</html>