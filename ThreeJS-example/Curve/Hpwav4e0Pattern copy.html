<!DOCTYPE html>
<html lang="en">

<head>
    <title>Example HPWAV4E0 Pattern</title>
    <meta charset="UTF-8">
    <script src="../js/three.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>

<body>
    <div id="WebGL-output">

    </div>
    <script>
        THREE.Math.polar = function(point, distance, angle) {
            var result = {};
            result.x = point.x + distance * Math.cos(angle);
            result.y = point.y + distance * Math.sin(angle);
            return result;
        };

        //=============================

        //지금 point에서 angle 방향으로 distance만큼 떨어져 있는 point 반환
        THREE.Math.clacPointOfLine = function(distance, len, angle) {
            let pos = [];

            //angle을 360도 내의 각도
            while (angle > (Math.PI * 2) || (angle < 0)) {

                if (angle < 0) {
                    angle = angle + (Math.PI * 2);
                } else if (angle > (Math.PI * 2)) {
                    angle = angle - (Math.PI * 2);
                }
            }

            let angle1, angle2;
            //pos[0] ==> 왼쪽
            //pos[1] ==> 오른쪽

            //angle ==> 왼쪽
            if (angle >= Math.PI * 0.5 && angle < (Math.PI * 0.5 * 3)) {
                angle1 = angle;
                //왼쪽 위
                if (angle1 < Math.PI) {
                    angle2 = angle1 + Math.PI;
                }
                //왼쪽 아래
                else {
                    angle2 = angle1 - Math.PI;
                }
            }
            //angle ==> 오른쪽
            else {
                angle2 = angle;
                //오른쪽 위
                if (angle2 >= 0 && angle2 < Math.PI) {
                    angle1 = angle2 + Math.PI;
                }
                //오른쪽 아래
                else {
                    angle1 = angle2 - Math.PI;
                }
            }

            //angle == 90 (x만 증가)
            if (angle1 == (Math.PI * 0.5)) {
                pos.push({
                    x: len * 0.5 * Math.cos(angle1) + distance,
                    y: len * 0.5 * Math.sin(angle1)
                });
                pos.push({
                    x: len * 0.5 * Math.cos(angle2) + distance,
                    y: len * 0.5 * Math.sin(angle2)
                });
            }
            //angle == 180 (y만 증가)
            else if (angle1 == Math.PI) {
                pos.push({
                    x: len * 0.5 * Math.cos(angle1),
                    y: len * 0.5 * Math.sin(angle1) + distance
                });
                pos.push({
                    x: len * 0.5 * Math.cos(angle2),
                    y: len * 0.5 * Math.sin(angle2) + distance
                });
            }
            //
            else {
                pos.push({
                    x: len * 0.5 * Math.cos(angle1) + distance,
                    y: len * 0.5 * Math.sin(angle1) + distance
                });
                pos.push({
                    x: len * 0.5 * Math.cos(angle2) + distance,
                    y: len * 0.5 * Math.sin(angle2) + distance
                });
            }

            //angle > 90    ex) 180 / 4 * 3 = 135 (x가 증가하면 y는 감소)
            // if (angle1 > (Math.PI * 0.5) && angle1 < Math.PI) {
            //     pos.push({
            //         x: len * 0.5 * Math.cos(angle1) + distance,
            //         y: len * 0.5 * Math.sin(angle1) + distance
            //     });
            //     pos.push({
            //         x: len * 0.5 * Math.cos(angle2) + distance,
            //         y: len * 0.5 * Math.sin(angle2) + distance
            //     });
            // }

            // //angle < 90    ex) 180 / 5 = 36 (x가 증가하면 y는 증가)
            // else if (angle1 < (Math.PI * 0.5)) {
            //     pos.push({
            //         x: len * 0.5 * Math.cos(angle1) + distance,
            //         y: len * 0.5 * Math.sin(angle1) - distance
            //     });
            //     pos.push({
            //         x: len * 0.5 * Math.cos(angle2) + distance,
            //         y: len * 0.5 * Math.sin(angle2) - distance
            //     });
            // }

            return pos;
        };
        // THREE.Math.clacPointOfLine = function(disX, disY, len, angle) {
        //     let pos = [];

        //     //angle을 360도 내의 각도
        //     while (angle > (Math.PI * 2) || (angle < 0)) {

        //         if (angle < 0) {
        //             angle = angle + (Math.PI * 2);
        //         } else if (angle > (Math.PI * 2)) {
        //             angle = angle - (Math.PI * 2);
        //         }
        //     }

        //     let angle1, angle2;
        //     //pos[0] ==> 왼쪽
        //     //pos[1] ==> 오른쪽

        //     //angle ==> 왼쪽
        //     if (angle >= Math.PI * 0.5 && angle < (Math.PI * 0.5 * 3)) {
        //         angle1 = angle;
        //         //왼쪽 위
        //         if (angle1 <= Math.PI) {
        //             angle2 = angle1 + Math.PI;
        //         }
        //         //왼쪽 아래
        //         else {
        //             angle2 = angle1 - Math.PI;
        //         }
        //     }
        //     //angle ==> 오른쪽
        //     else {
        //         angle2 = angle;
        //         //오른쪽 위
        //         if (angle2 >= 0 && angle2 < Math.PI) {
        //             angle1 = angle2 + Math.PI;
        //         }
        //         //오른쪽 아래
        //         else {
        //             angle1 = angle2 - Math.PI;
        //         }
        //     }


        //     //angle > 90    ex) 180 / 4 * 3 = 135 (x가 증가하면 y는 감소)
        //     if (angle > (Math.PI * 0.5) && angle < Math.PI) {
        //         pos.push({
        //             x: len * 0.5 * Math.cos(angle1) + disX,
        //             y: len * 0.5 * Math.sin(angle1) + disY
        //         });
        //         pos.push({
        //             x: len * 0.5 * Math.cos(angle2) + disX,
        //             y: len * 0.5 * Math.sin(angle2) + disY
        //         });
        //     }
        //     //angle == 90 (x만 증가)
        //     else if (angle == (Math.PI * 0.5)) {
        //         pos.push({
        //             x: len * 0.5 * Math.cos(angle1) + disX,
        //             y: len * 0.5 * Math.sin(angle1)
        //         });
        //         pos.push({
        //             x: len * 0.5 * Math.cos(angle2) + disX,
        //             y: len * 0.5 * Math.sin(angle2)
        //         });
        //     }
        //     //angle == 0 (y만 증가)
        //     else if (angle == 0) {
        //         pos.push({
        //             x: len * 0.5 * Math.cos(angle1),
        //             y: len * 0.5 * Math.sin(angle1) + disY
        //         });
        //         pos.push({
        //             x: len * 0.5 * Math.cos(angle2),
        //             y: len * 0.5 * Math.sin(angle2) + disY
        //         });
        //     }
        //     //angle < 90    ex) 180 / 5 = 36 (x가 증가하면 y는 증가)
        //     else if (angle < (Math.PI * 0.5)) {
        //         pos.push({
        //             x: len * 0.5 * Math.cos(angle1) + disX,
        //             y: len * 0.5 * Math.sin(angle1) - disY
        //         });
        //         pos.push({
        //             x: len * 0.5 * Math.cos(angle2) + disX,
        //             y: len * 0.5 * Math.sin(angle2) - disY
        //         });
        //     }

        //     return pos;
        // };

        //로딩이 끝나면 Three.js를 숭행한다.
        function init() {
            //여기에 Three.js코드를 추가한다.
            let scene = new THREE.Scene();
            let camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
            camera.position.set(0, 0, 500);
            let renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight);
            //html 추가
            document.body.appendChild(renderer.domElement);

            //원래 0각도에서의 각 시작 점들
            //0, 30
            //25, 38
            //110, 30

            let scale = 1;

            //<spline에 대한>
            //spline선의 각 고지점의 간격
            let hDistance = 8 * scale;
            let wDistance = 25 * scale; //일정하게 하기 위해 25로 
            //다음 선의 간격
            let distance = 60 * scale;
            //시작 점
            let x = 0 * scale;
            let y = 30 * scale;

            //<pattern에 대한>
            let maxLen = 300;
            let rowCount = maxLen / distance;
            let colCount = maxLen / (wDistance * 2) + 1;

            let parent = new THREE.Object3D();
            let material = new THREE.LineBasicMaterial({
                color: 0xffff00
            });

            //===========================================================================
            let i, j, e;
            let upAngle = Math.atan(hDistance / wDistance);
            let downAngle = Math.atan(-hDistance / wDistance);
            let len = Math.sqrt(Math.pow(wDistance, 2) + Math.pow(hDistance, 2));
            let angle = 0;

            // THREE.Math.polar = function(point, distance, angle);
            //행
            for (i = 0; i < rowCount; i++) {
                //(-maxLen * 0.5) + (distance * i)
                let pos = THREE.Math.clacPointOfLine((-maxLen * 0.5) + (distance * i), maxLen, angle);
                //중심이 되는 선을 간격 만큼 나눈다.
                // let oriLine = new THREE.LineCurve(new THREE.Vector2(pos[0].x, pos[0].y), new THREE.Vector2(pos[1].x, pos[1].y));
                // let points = oriLine.getPoints(colCount);

                let curve = new THREE.SplineCurve([new THREE.Vector2(pos[0].x, pos[0].y)]);
                //
                let downPos = new THREE.Vector2(pos[0].x, pos[0].y);
                let upPos;
                for (j = 0; j < colCount; j++) {
                    upPos = THREE.Math.polar(downPos, len, upAngle + angle);
                    downPos = THREE.Math.polar(upPos, len, downAngle + angle);

                    curve.points.push(new THREE.Vector2(upPos.x, upPos.y));
                    curve.points.push(new THREE.Vector2(downPos.x, downPos.y));
                }

                let curvePos = curve.getPoints(50);
                let geometry = new THREE.BufferGeometry().setFromPoints(curvePos);
                let spline = new THREE.Line(geometry, material);
                parent.add(spline);

            }

            scene.add(parent);

            let geometry = new THREE.Geometry();
            geometry.vertices.push(
                new THREE.Vector3((-maxLen * 0.5), (-maxLen * 0.5), 0),
                new THREE.Vector3((maxLen * 0.5), (-maxLen * 0.5), 0),
                new THREE.Vector3((maxLen * 0.5), (maxLen * 0.5), 0),
                new THREE.Vector3((-maxLen * 0.5), (maxLen * 0.5), 0),
                new THREE.Vector3((-maxLen * 0.5), (-maxLen * 0.5), 0)
            );

            let line = new THREE.Line(geometry, material);
            scene.add(line);

            // //행
            // for (i = 0; i < rowCount; i++) {

            //     let pos = THREE.Math.clacPointOfLine((-maxLen * 0.5) + (distance * i), maxLen, Math.PI * 0.5);
            //     //중심이 되는 선을 간격 만큼 나눈다.
            //     let oriLine = new THREE.LineCurve(new THREE.Vector2(pos[0].x, pos[0].y), new THREE.Vector2(pos[1].x, pos[1].y));
            //     let points = oriLine.getPoints(colCount * 2);

            //     let curve = new THREE.SplineCurve([new THREE.Vector2(points[0].x, points[0].y)]);

            //     for (j = 1; j < points.length; j += 2) {

            //         curve.points.push(new THREE.Vector2(points[j].x, points[j].y + hDistance));
            //         curve.points.push(new THREE.Vector2(points[j + 1].x, points[j + 1].y));
            //     }

            //     let curvePos = curve.getPoints(50);
            //     let geometry = new THREE.BufferGeometry().setFromPoints(curvePos);
            //     let spline = new THREE.Line(geometry, material);
            //     parent.add(spline);

            // }

            // scene.add(parent);

            // let geometry = new THREE.Geometry();
            // geometry.vertices.push(
            //     new THREE.Vector3((-maxLen * 0.5), (-maxLen * 0.5), 0),
            //     new THREE.Vector3((maxLen * 0.5), (-maxLen * 0.5), 0),
            //     new THREE.Vector3((maxLen * 0.5), (maxLen * 0.5), 0),
            //     new THREE.Vector3((-maxLen * 0.5), (maxLen * 0.5), 0),
            //     new THREE.Vector3((-maxLen * 0.5), (-maxLen * 0.5), 0)
            // );

            // let line = new THREE.Line(geometry, material);
            // scene.add(line);
            //===========================================================================


            renderer.render(scene, camera);
        };

        init();
    </script>
</body>

</html>